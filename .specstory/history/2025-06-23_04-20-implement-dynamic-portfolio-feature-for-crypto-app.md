<!-- Generated by SpecStory -->

# Implement dynamic portfolio feature for crypto app (2025-06-23 00:20:54)

_**User**_

You are a senior software engineer with expertise in React Native, TypeScript, and pixel-perfect UI implementation.

We are implementing a dynamic portfolio feature for a static crypto app. This feature should support only BTC and SOL assets and dynamically calculate fiat values using real-time price data. Below is the complete context and the required step-by-step implementation plan.  Replace all hardcoded fiat values in the portfolio UI with dynamically calculated values using live prices for BTC and SOL only. Architecture Context

Current Component & Data Flow  portfolioData.ts (static) 
  → AssetRow 
    → AssetRowLayout 
      → CurrencyUnitValue (left: "1.5 BTC") 
      → CounterValue (right: "$45.2k") 
 Main Portfolio Balance Display
	•	File: GraphCard.tsx
	•	Line ~230–240: Renders balance via <CurrencyUnitValue />
	•	Line ~250–265: Renders change via <Delta />   Phase-by-Phase Implementation Plan

⸻

Phase 1: Price Fetching Layer

Task: Create a service to fetch live prices from CoinGecko.
	•	Endpoint:
https://api.coingecko.com/api/v3/simple/price?ids=${cryptoIds.join(',')}&vs_currencies=usd
	•	Steps:
	•	Create PriceService.ts
	•	Fetch prices for BTC and SOL only  Phase 2: Global Price Context

Task: Add global state management for real-time prices.
	•	File: src/context/PriceContext.tsx
	•	Create PriceProvider and usePriceContext hook
	•	Store and provide live prices for BTC and SOL Phase 3: App Integration

Task: Integrate the context into the app.
	•	Modify App.tsx
	•	Wrap the app in <PriceProvider>   Phase 4: Dynamic Fiat Value Rendering

Task: Refactor CounterValue to use live price context.
	•	File: src/components/CounterValue.tsx
	•	Remove hardcoded fiat logic  	•	Replace with live price lookup and amount * price calculation 
⸻

Phase 5: Portfolio Data Refactor (only include bitcoin and solana as assets) 

Task: Adjust asset structure to support dynamic values.
	•	File: @@portfolioData.ts src/constants/portfolioData.ts
	•	Keep only crypto amounts (e.g., 1 BTC, 3 SOL)
	•	Remove all hardcoded fiat values
	•	Store crypto amounts in smallest units for precision (e.g., sats) 
 Phase 6: AssetRowLayout Data Flow

Task: Ensure AssetRowLayout uses the new dynamic value flow.
	•	Modify how props are passed to CounterValue
	•	Ensure CurrencyUnitValue shows crypto amount
	•	Ensure CounterValue calculates live fiat value  Phase 7: GraphCard Balance Update

Task: Update the main portfolio balance display.
	•	File: @@GraphCard.tsx src/components/GraphCard.tsx
	•	Use live prices to dynamically compute:
	•	Total fiat balance
	•	Percentage change
	•	Dollar change
	•	Affected lines: ~230–265  Special Considerations
	•	Crypto Limit: Only handle BTC and SOL. No other assets.
	•	Unit Handling: BTC (8 decimals), SOL (9 decimals)
	•	Precision: Use BigNumber to handle all calculations
	•	Display Consistency: Match formatting shown in original static UI (e.g., $101,168.00)  Target Output
	•	Fully dynamic fiat rendering for BTC and SOL
	•	Pixel-perfect replication of the static layout
	•	Updated components: CounterValue, GraphCard, AssetRowLayout
	•	Clean architecture: context-driven, scalable 

---

_**Assistant**_



---

I'll implement the dynamic portfolio feature phase by phase, focusing only on BTC and SOL assets with live price data. Let me start by examining the current structure and then implementing each phase systematically.

---

<details>
            <summary>Searched codebase "CounterValue CurrencyUnitValue fiat conversion hardcoded static" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `UIReplicationLedger/src/components/CounterValue.tsx` | L26-65 |
| `ledger-live/libs/ledgerjs/packages/cryptoassets/src/fiats.ts` | L21-62 |
| `ledger-live/libs/ledgerjs/packages/cryptoassets/src/fiats.ts` | L103-143 |
| `ledger-live/libs/ledgerjs/packages/cryptoassets/src/fiats.ts` | L143-182 |
| `UIReplicationLedger/src/constants/portfolioData.ts` | L39-104 |
| `ledger-live/libs/ledgerjs/packages/cryptoassets/src/fiats.ts` | L62-103 |
| `ledger-live/libs/ledger-live-common/src/market/utils/countervalueFormatter.ts` | L1-22 |
| `ledger-live/libs/ledger-live-common/src/currencies/valueFromUnit.ts` | L1-10 |
| `ledger-live/libs/live-countervalues/src/mock.test.ts` | L1-13 |
| `ledger-live/libs/ledgerjs/packages/cryptoassets/src/fiats.ts` | L1-21 |
| `ledger-live/libs/live-countervalues/src/mock.ts` | L1-2 |
| `ledger-live/libs/live-countervalues-react/src/index.tsx` | L393-437 |
| `ledger-live/libs/ledger-live-common/src/csvExport.ts` | L88-152 |
| `UIReplicationLedger/src/components/CounterValue.tsx` | L1-15 |
| `ledger-live/libs/live-countervalues/src/helpers.ts` | L78-82 |
| `UIReplicationLedger/src/constants/portfolioData.ts` | L1-31 |
| `ledger-live/libs/coin-framework/src/currencies/CurrencyURIScheme.ts` | L27-36 |
| `ledger-live/libs/coin-framework/src/currencies/localeUtility.ts` | L9-20 |
| `UIReplicationLedger/src/constants/portfolioData.ts` | L104-188 |
| `ledger-live/libs/ledger-live-common/src/currencies/support.ts` | L1-60 |
| `ledger-live/libs/ledgerjs/packages/cryptoassets/src/fiats.ts` | L182-196 |
| `ledger-live/libs/live-countervalues/src/portfolio.ts` | L477-505 |
| `ledger-live/libs/ledger-live-common/scripts/listMarketPriceFor1USD.js` | L1-58 |
| `ledger-live/libs/coin-modules/coin-filecoin/src/common-logic/utils.ts` | L224-232 |
| `UIReplicationLedger/assetlist.md` | L169-239 |

</details>

---



---

Now I'll implement the dynamic portfolio feature phase by phase. Let me start with **Phase 1: Price Fetching Layer**.

---

```diff
- 
+ import { BigNumber } from "bignumber.js";
+ 
+ export interface LivePrice {
+   id: string;
+   usd: number;
+   usd_24h_change: number;
+   last_updated_at: number;
+ }
+ 
+ export interface PriceData {
+   [key: string]: LivePrice;
+ }
+ 
+ // Supported crypto currencies for live pricing (BTC and SOL only)
+ const SUPPORTED_CRYPTOS = {
+   bitcoin: 'bitcoin',
+   solana: 'solana',
+ } as const;
+ 
+ export type SupportedCryptoId = keyof typeof SUPPORTED_CRYPTOS;
+ 
+ class PriceService {
+   private static instance: PriceService;
+   private baseUrl = 'https://api.coingecko.com/api/v3';
+   private cache: Map<string, { data: PriceData; timestamp: number }> = new Map();
+   private cacheTimeout = 60000; // 1 minute cache
+ 
+   static getInstance(): PriceService {
+     if (!PriceService.instance) {
+       PriceService.instance = new PriceService();
+     }
+     return PriceService.instance;
+   }
+ 
+   /**
+    * Fetch live prices for BTC and SOL from CoinGecko
+    */
+   async fetchPrices(): Promise<PriceData> {
+     const cacheKey = 'live-prices';
+     const cached = this.cache.get(cacheKey);
+     
+     // Return cached data if still valid
+     if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
+       return cached.data;
+     }
+ 
+     try {
+       const cryptoIds = Object.values(SUPPORTED_CRYPTOS).join(',');
+       const url = `${this.baseUrl}/simple/price?ids=${cryptoIds}&vs_currencies=usd&include_24hr_change=true&include_last_updated_at=true`;
+       
+       console.log('[PriceService] Fetching prices from:', url);
+       
+       const response = await fetch(url);
+       
+       if (!response.ok) {
+         throw new Error(`HTTP error! status: ${response.status}`);
+       }
+       
+       const data = await response.json();
+       
+       // Transform API response to our format
+       const priceData: PriceData = {};
+       
+       for (const [cryptoId, priceInfo] of Object.entries(data)) {
+         if (typeof priceInfo === 'object' && priceInfo !== null) {
+           const info = priceInfo as any;
+           priceData[cryptoId] = {
+             id: cryptoId,
+             usd: info.usd || 0,
+             usd_24h_change: info.usd_24h_change || 0,
+             last_updated_at: info.last_updated_at || Date.now() / 1000,
+           };
+         }
+       }
+       
+       // Cache the result
+       this.cache.set(cacheKey, {
+         data: priceData,
+         timestamp: Date.now(),
+       });
+       
+       console.log('[PriceService] Fetched prices:', priceData);
+       return priceData;
+       
+     } catch (error) {
+       console.error('[PriceService] Error fetching prices:', error);
+       
+       // Return cached data if available, otherwise fallback prices
+       if (cached) {
+         console.log('[PriceService] Using cached data due to error');
+         return cached.data;
+       }
+       
+       // Fallback prices if no cache available
+       return this.getFallbackPrices();
+     }
+   }
+ 
+   /**
+    * Get price for specific cryptocurrency
+    */
+   async getPrice(cryptoId: SupportedCryptoId): Promise<number> {
+     const prices = await this.fetchPrices();
+     const coinGeckoId = SUPPORTED_CRYPTOS[cryptoId];
+     return prices[coinGeckoId]?.usd || 0;
+   }
+ 
+   /**
+    * Calculate fiat value for crypto amount
+    */
+   async calculateFiatValue(
+     cryptoId: SupportedCryptoId,
+     amount: BigNumber,
+     decimals: number = 8
+   ): Promise<BigNumber> {
+     const price = await this.getPrice(cryptoId);
+     const adjustedAmount = amount.dividedBy(new BigNumber(10).pow(decimals));
+     return adjustedAmount.multipliedBy(price);
+   }
+ 
+   /**
+    * Get 24h change percentage for crypto
+    */
+   async get24hChange(cryptoId: SupportedCryptoId): Promise<number> {
+     const prices = await this.fetchPrices();
+     const coinGeckoId = SUPPORTED_CRYPTOS[cryptoId];
+     return prices[coinGeckoId]?.usd_24h_change || 0;
+   }
+ 
+   /**
+    * Fallback static prices for development/error scenarios
+    */
+   private getFallbackPrices(): PriceData {
+     console.log('[PriceService] Using fallback prices');
+     return {
+       bitcoin: {
+         id: 'bitcoin',
+         usd: 45000,
+         usd_24h_change: 2.5,
+         last_updated_at: Date.now() / 1000,
+       },
+       solana: {
+         id: 'solana',
+         usd: 100,
+         usd_24h_change: -1.2,
+         last_updated_at: Date.now() / 1000,
+       },
+     };
+   }
+ 
+   /**
+    * Clear cache (useful for testing or forced refresh)
+    */
+   clearCache(): void {
+     this.cache.clear();
+   }
+ }
+ 
+ export default PriceService.getInstance(); 
```

---



---

Now **Phase 2: Global Price Context**. I'll create a context to manage live prices globally.

---

```diff
- 
+ import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';
+ import { BigNumber } from 'bignumber.js';
+ import PriceService, { PriceData, SupportedCryptoId } from '../services/PriceService';
+ 
+ interface PriceContextType {
+   prices: PriceData;
+   loading: boolean;
+   error: string | null;
+   lastUpdated: Date | null;
+   getPrice: (cryptoId: SupportedCryptoId) => number;
+   calculateFiatValue: (cryptoId: SupportedCryptoId, amount: BigNumber, decimals?: number) => BigNumber;
+   get24hChange: (cryptoId: SupportedCryptoId) => number;
+   refreshPrices: () => Promise<void>;
+ }
+ 
+ const PriceContext = createContext<PriceContextType | undefined>(undefined);
+ 
+ export const usePriceContext = (): PriceContextType => {
+   const context = useContext(PriceContext);
+   if (!context) {
+     throw new Error('usePriceContext must be used within a PriceProvider');
+   }
+   return context;
+ };
+ 
+ interface PriceProviderProps {
+   children: ReactNode;
+   refreshInterval?: number; // in milliseconds
+ }
+ 
+ export const PriceProvider: React.FC<PriceProviderProps> = ({ 
+   children, 
+   refreshInterval = 60000 // 1 minute default
+ }) => {
+   const [prices, setPrices] = useState<PriceData>({});
+   const [loading, setLoading] = useState<boolean>(true);
+   const [error, setError] = useState<string | null>(null);
+   const [lastUpdated, setLastUpdated] = useState<Date | null>(null);
+ 
+   const fetchPrices = async () => {
+     try {
+       setError(null);
+       const priceData = await PriceService.fetchPrices();
+       setPrices(priceData);
+       setLastUpdated(new Date());
+       console.log('[PriceContext] Prices updated:', priceData);
+     } catch (err) {
+       const errorMessage = err instanceof Error ? err.message : 'Failed to fetch prices';
+       setError(errorMessage);
+       console.error('[PriceContext] Error fetching prices:', err);
+     } finally {
+       setLoading(false);
+     }
+   };
+ 
+   const refreshPrices = async () => {
+     setLoading(true);
+     await fetchPrices();
+   };
+ 
+   const getPrice = (cryptoId: SupportedCryptoId): number => {
+     const coinGeckoId = cryptoId === 'bitcoin' ? 'bitcoin' : 'solana';
+     return prices[coinGeckoId]?.usd || 0;
+   };
+ 
+   const calculateFiatValue = (
+     cryptoId: SupportedCryptoId, 
+     amount: BigNumber, 
+     decimals: number = 8
+   ): BigNumber => {
+     const price = getPrice(cryptoId);
+     if (price === 0) {
+       return new BigNumber(0);
+     }
+     
+     const adjustedAmount = amount.dividedBy(new BigNumber(10).pow(decimals));
+     return adjustedAmount.multipliedBy(price);
+   };
+ 
+   const get24hChange = (cryptoId: SupportedCryptoId): number => {
+     const coinGeckoId = cryptoId === 'bitcoin' ? 'bitcoin' : 'solana';
+     return prices[coinGeckoId]?.usd_24h_change || 0;
+   };
+ 
+   useEffect(() => {
+     // Initial fetch
+     fetchPrices();
+ 
+     // Set up interval for periodic updates
+     const interval = setInterval(fetchPrices, refreshInterval);
+ 
+     return () => {
+       clearInterval(interval);
+     };
+   }, [refreshInterval]);
+ 
+   const contextValue: PriceContextType = {
+     prices,
+     loading,
+     error,
+     lastUpdated,
+     getPrice,
+     calculateFiatValue,
+     get24hChange,
+     refreshPrices,
+   };
+ 
+   return (
+     <PriceContext.Provider value={contextValue}>
+       {children}
+     </PriceContext.Provider>
+   );
+ }; 
```

---



---

Now **Phase 3: App Integration**. I'll wrap the app with the PriceProvider.

---



---



---

Now **Phase 4: Dynamic Fiat Value Rendering**. I'll refactor `CounterValue.tsx` to use live prices.

---



---



---

Now **Phase 5: Portfolio Data Refactor**. I'll update the portfolio data to only include BTC and SOL, removing all hardcoded fiat values.

---



---



---

I need to update the tab data to reflect the new asset count:

---



---



---

Now I need to check and update the **Delta** component to use live price changes. Let me first examine it:

---

Read file: src/components/Delta.tsx

---



---

I need to update the `AssetRowLayout` component to use dynamic 24h price changes. Let me modify it:

---



---



---



---



---

Now for **Phase 7: GraphCard Balance Update**. I need to update the main portfolio balance display to use dynamic calculations:

---

Read file: src/components/GraphCard.tsx

---



---

I need to update GraphCard to use dynamic portfolio calculations. Let me add the price context and modify the balance calculations:

---



---



---



---



---

Perfect! I've successfully implemented all 7 phases of the dynamic portfolio feature. Let me now test the implementation to ensure everything works correctly:

---

```bash
cd UIReplicationLedger && npx react-native run-ios --simulator="iPhone 15"
```

---

_**User**_

on the fiatbalances in @AssetRowLayout.tsx when i set it as 1 btc its correctly showing the balance, but its saying $151.8k instead of  (e.g: 101,168.00) change how its formatted to show the entire number, including if its in the millions  like in provided image

---

_**Assistant**_



---

I can see the issue! The `CounterValue` component is using the "k" abbreviation format (like $151.8k) instead of showing the full number with commas. Looking at your screenshot, the fiat values should display as full numbers like $8,562,791.95 and $1,080,870.82.

Let me fix the formatting in the `CounterValue.tsx` component:

---



---



---

Perfect! I've updated the `CounterValue` component to show full numbers with proper formatting instead of the abbreviated "k" format. Now it will:

1. **Display full numbers** with comma separators and exactly 2 decimal places for amounts ≥ $1
2. **Show 4 decimal places** for very small amounts < $1 
3. **Remove the "k" abbreviation** completely

This matches the format shown in your screenshot where:
- Bitcoin shows `$8,562,791.95` (full number with commas)
- Solana shows `$1,080,870.82` (full number with commas)

The formatting now uses `toLocaleString('en-US')` with `minimumFractionDigits: 2` and `maximumFractionDigits: 2` to ensure consistent display of full amounts with proper comma separators, whether it's hundreds, thousands, or millions of dollars.

Your 1 BTC should now display something like `$101,168.00` instead of `$151.8k` depending on the current live Bitcoin price.

---

