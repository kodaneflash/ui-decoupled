<!-- Generated by SpecStory -->

# Debugging delta component percentage issues (2025-07-06 13:32Z)

_**User**_

We have a React Native app that replicates Ledger Live's portfolio functionality. Analyze related components in ledger-live-mobile, the app we are replicating for 100% fidelity and consistent behavior. The data flow is:
PriceContext → Fetches crypto prices & calculates changes
PortfolioDataContext → Aggregates portfolio-level changes
GraphCard → Displays main portfolio balance with Delta component
AssetRowLayout → Shows individual asset rows with Delta components  Current Issue
The Delta component is showing 0% when it should display actual percentage changes:
1d/7d timeframes: Individual assets show meaningful changes but Delta displays 0%
1w timeframe: Solana shows -2% change but main portfolio Delta still shows 0%  // Individual asset (working correctly)
LOG [GraphCard] 1w change for solana: {"percentage": -0.018870779203589545} // -1.89%

// Portfolio level (problematic)  
LOG [GraphCard] Portfolio 1w change: {"changePercentage": -0.0006217816629992531} // -0.0006%  Goal
Add comprehensive debug logs to identify why:
Portfolio-level changes are extremely small vs individual asset changes
Delta component receives wrong data in different contexts
The show0Delta parameter behavior across timeframes  Required Debug Logs
Add logs in these components to trace data flow:
Delta.tsx - Log all input props and calculated values
GraphCard.tsx - Log portfolio vs individual asset data
AssetRowLayout.tsx - Log individual asset percentage calculations
PortfolioDataContext.tsx - Log portfolio aggregation logic  Expected Outcome
Identify whether the issue is:
Wrong data being passed to Delta component
Incorrect portfolio aggregation logic
Delta component filtering logic being too aggressive
Missing/incorrect show0Delta parameter usage 

---

_**Assistant**_

<think><details><summary>Thought Process</summary>The user is asking me to analyze a React Native app that replicates Ledger Live's portfolio functionality. They're experiencing an issue where the Delta component is showing 0% when it should display actual percentage changes. The user wants me to add comprehensive debug logs to identify the root cause.

Looking at the attached files, I can see:

1. `Delta.tsx` - The component that displays percentage changes
2. `GraphCard.tsx` - Displays main portfolio balance with Delta component
3. `AssetRowLayout.tsx` - Shows individual asset rows with Delta components
4. `CounterValue.tsx` - Handles currency value formatting
5. `CurrencyUnitValue.tsx` - Handles currency unit value formatting
6. `AssetRow.tsx` - Individual asset row component
7. `PortfolioDataContext.tsx` - Manages portfolio data

From the logs provided, I can see that individual assets are showing meaningful changes (like Solana showing -1.89% change) but the portfolio-level Delta is showing very small changes (-0.0006%).

The user wants me to add debug logs to identify:
1. Why portfolio-level changes are extremely small vs individual asset changes
2. Why Delta component receives wrong data in different contexts
3. The show0Delta parameter behavior across timeframes

I need to add comprehensive debug logs in:
- Delta.tsx - Log all input props and calculated values
- GraphCard.tsx - Log portfolio vs individual asset data
- AssetRowLayout.tsx - Log individual asset percentage calculations  
- PortfolioDataContext.tsx - Log portfolio aggregation logic

Let me start by adding debug logs to each component systematically.</details></think>

---

I'll analyze the data flow and add comprehensive debug logs to identify why the Delta component is showing 0% when it should display actual percentage changes. Let me add debug logs to trace the data flow through each component.

---

```diff
  }) => {
    const { colors } = useTheme();
+ 
+   // DEBUG: Log all input props and context
+   console.log('[Delta] Input props:', {
+     valueChange,
+     percent,
+     show0Delta,
+     fallbackToPercentPlaceholder,
+     isArrowDisplayed,
+     unit: unit?.code,
+     range,
+     timestamp: new Date().toISOString(),
+   });
  
    const percentPlaceholder = fallbackToPercentPlaceholder ? (
```

```diff
  
    if (!valueChange) {
+     console.log('[Delta] No valueChange provided, returning placeholder');
      return percentPlaceholder;
    }
  
    const { percentage, value } = valueChange;
+   
+   // DEBUG: Log raw values before processing
+   console.log('[Delta] Raw values:', {
+     percentage,
+     value,
+     percentageType: typeof percentage,
+     valueType: typeof value,
+   });
    
    // Handle the delta calculation - percentage is already in decimal format (0-1)
    const delta = percent ? percentage * 100 : value;
    const roundedDelta = parseFloat(delta.toFixed(percent ? 0 : 2));
+ 
+   // DEBUG: Log calculated values
+   console.log('[Delta] Calculated values:', {
+     delta,
+     roundedDelta,
+     percent,
+     deltaAfterMultiply: percent ? percentage * 100 : 'N/A',
+     isZero: roundedDelta === 0,
+     show0Delta,
+   });
  
    if (roundedDelta === 0 && !show0Delta) {
+     console.log('[Delta] Returning placeholder because roundedDelta is 0 and show0Delta is false');
      return percentPlaceholder;
    }
```

```diff
          : ["neutral.c70", null, ""];
  
+   // DEBUG: Log color and arrow selection
+   console.log('[Delta] Display properties:', {
+     color,
+     ArrowIcon: ArrowIcon?.name || 'null',
+     sign,
+     roundedDelta,
+   });
+ 
    if (
      percent &&
```

```diff
        percentage === undefined)
    ) {
+     console.log('[Delta] Returning early due to percentage conditions:', {
+       percentage,
+       show0Delta,
+       isPercent: percent,
+     });
      if (fallbackToPercentPlaceholder) return percentPlaceholder;
      if (percent && isArrowDisplayed && ArrowIcon) return <ArrowIcon size={20} color={color} />;
```

```diff
  
    if (Number.isNaN(delta)) {
+     console.log('[Delta] Delta is NaN, returning fallback');
      if (percent && fallbackToPercentPlaceholder) return percentPlaceholder;
      return null;
```

```diff
    const absDelta = Math.abs(roundedDelta);
    const absValue = Math.abs(value);
+ 
+   // DEBUG: Log final display values
+   console.log('[Delta] Final display values:', {
+     absDelta,
+     absValue,
+     unit: unit?.code,
+     displayText: percent ? `${absDelta.toFixed(0)}%` : 'currency',
+     willShowArrow: percent && isArrowDisplayed && ArrowIcon,
+   });
  
    return (
```

---

<think><details><summary>Thought Process</summary>Good, I've added comprehensive debug logs to the Delta component. Now let me add debug logs to the GraphCard component to track portfolio vs individual asset data.</details></think>

---

```diff
    };
  
+   // Calculate dynamic countervalue change
    const calculatePortfolioChange = useCallback(async (): Promise<{ value: number; percentage: number }> => {
+     console.log('[GraphCard] calculatePortfolioChange called:', {
+       loading,
+       areAccountsEmpty,
+       selectedRange,
+       timestamp: new Date().toISOString(),
+     });
+ 
      if (loading || areAccountsEmpty) {
+       console.log('[GraphCard] Early return due to loading or empty accounts');
        return { value: 0, percentage: 0 };
      }
```

```diff
        changePercentage: changePercentage,
      });
+ 
+     // DEBUG: Additional portfolio calculation analysis
+     console.log('[GraphCard] Portfolio calculation analysis:', {
+       totalCurrentValue: totalCurrentValue.toNumber(),
+       totalPreviousValue: totalPreviousValue.toNumber(),
+       totalChange: totalChange.toNumber(),
+       changePercentage,
+       changePercentageAsPercent: (changePercentage * 100).toFixed(4) + '%',
+       isChangeSmall: Math.abs(changePercentage) < 0.01,
+       isChangeVerySmall: Math.abs(changePercentage) < 0.001,
+       previousValueIsZero: totalPreviousValue.isZero(),
+     });
  
      return {
```

```diff
        console.log(`[GraphCard] Updating portfolio change for timeframe: ${selectedRange}`);
        const newCountervalueChange = await calculatePortfolioChange();
+       
+       // DEBUG: Log before and after state update
+       console.log('[GraphCard] Portfolio change state update:', {
+         previousState: dynamicCountervalueChange,
+         newState: newCountervalueChange,
+         timeframe: selectedRange,
+       });
+       
        setDynamicCountervalueChange(newCountervalueChange);
      };
```

```diff
      countervalueChange: loading ? portfolioData.countervalueChange : dynamicCountervalueChange,
    };
+ 
+   // DEBUG: Log portfolio data construction
+   console.log('[GraphCard] Portfolio data constructed:', {
+     isUsingDynamicCountervalueChange: !loading,
+     staticCountervalueChange: portfolioData.countervalueChange,
+     dynamicCountervalueChange,
+     finalCountervalueChange: portfolio.countervalueChange,
+     selectedRange,
+     loading,
+   });
  
    const counterValueCurrency: Currency = counterValueCurrencyProp || {
```

```diff
  
    const {countervalueChange, balanceHistory} = portfolio;
-   
+   
+   // DEBUG: Log the countervalue change that will be passed to Delta
+   console.log('[GraphCard] Countervalue change for Delta:', {
+     countervalueChange,
+     balanceHistory: balanceHistory?.length || 0,
+     selectedRange,
+     show0Delta: true, // This component uses show0Delta=true
+   });
+ 
    // DEFENSIVE: Handle empty balanceHistory like Ledger Live
    const item = balanceHistory && balanceHistory.length > 0 
```

```diff
                        ) : (
                          <>
+                           {/* DEBUG: Log Delta props before rendering */}
+                           {console.log('[GraphCard] About to render Delta with props:', {
+                             percent: true,
+                             show0Delta: true,
+                             valueChange: countervalueChange,
+                             context: 'portfolio-percentage',
+                             selectedRange,
+                           })}
                            <Delta
                              percent
```

```diff
                            />
                            <Text> </Text>
+                           {/* DEBUG: Log Delta props before rendering */}
+                           {console.log('[GraphCard] About to render Delta with props:', {
+                             unit: unit,
+                             valueChange: countervalueChange,
+                             context: 'portfolio-value',
+                             selectedRange,
+                           })}
                            <Delta 
                              unit={unit} 
```

---

<think><details><summary>Thought Process</summary>Now let me add debug logs to the AssetRowLayout component to track individual asset percentage calculations.</details></think>

---

```diff
    useEffect(() => {
      const calculateTimeframeChange = async () => {
+       console.log(`[AssetRowLayout] calculateTimeframeChange called for ${currency.id}:`, {
+         currencyId: currency.id,
+         selectedTimeframe,
+         loading,
+         balanceNumber: balance.toNumber(),
+         staticCountervalueChange,
+       });
+ 
        const supportedCryptoId = getSupportedCryptoId(currency.id);
        
        if (!supportedCryptoId || loading) {
-         console.log(`[AssetRowLayout] Using static data for ${currency.id} - not supported or loading`);
+         console.log(`[AssetRowLayout] Using static data for ${currency.id} - not supported or loading:`, {
+           supportedCryptoId,
+           loading,
+           staticCountervalueChange,
+         });
          setDynamicCountervalueChange(staticCountervalueChange);
          return;
```

```diff
          );
          
-         console.log(`[AssetRowLayout] ${selectedTimeframe} change result for ${supportedCryptoId}:`, valueChangeData);
-         
-         setDynamicCountervalueChange({
+         console.log(`[AssetRowLayout] ${selectedTimeframe} change result for ${supportedCryptoId}:`, {
+           ...valueChangeData,
+           percentageAsPercent: (valueChangeData.percentage * 100).toFixed(4) + '%',
+           isPercentageSmall: Math.abs(valueChangeData.percentage) < 0.01,
+           isPercentageVerySmall: Math.abs(valueChangeData.percentage) < 0.001,
+         });
+         
+         const newCountervalueChange = {
            value: valueChangeData.value,
            percentage: valueChangeData.percentage, // Already in decimal format
-         });
+         };
+ 
+         // DEBUG: Compare with static data
+         console.log(`[AssetRowLayout] Comparison for ${supportedCryptoId}:`, {
+           staticCountervalueChange,
+           newCountervalueChange,
+           difference: {
+             value: newCountervalueChange.value - (staticCountervalueChange?.value || 0),
+             percentage: newCountervalueChange.percentage - (staticCountervalueChange?.percentage || 0),
+           },
+         });
+         
+         setDynamicCountervalueChange(newCountervalueChange);
          
        } catch (error) {
```

```diff
    // Use dynamic calculation if available, fallback to static
    const countervalueChange = dynamicCountervalueChange || staticCountervalueChange;
+ 
+   // DEBUG: Log final countervalue change before rendering
+   console.log(`[AssetRowLayout] Final countervalue change for ${currency.id}:`, {
+     countervalueChange,
+     dynamicCountervalueChange,
+     staticCountervalueChange,
+     selectedTimeframe,
+     willShowDelta: !hideDelta && countervalueChange,
+   });
  
    return (
```

```diff
              </Text>
              {!hideDelta && countervalueChange && (
-               <Delta
-                 percent
-                 show0Delta={balance.toNumber() !== 0}
-                 fallbackToPercentPlaceholder
-                 valueChange={countervalueChange}
-               />
+               <>
+                 {/* DEBUG: Log Delta props before rendering */}
+                 {console.log(`[AssetRowLayout] About to render Delta for ${currency.id}:`, {
+                   percent: true,
+                   show0Delta: balance.toNumber() !== 0,
+                   fallbackToPercentPlaceholder: true,
+                   valueChange: countervalueChange,
+                   context: 'asset-row',
+                   selectedTimeframe,
+                   balanceIsZero: balance.toNumber() === 0,
+                 })}
+                 <Delta
+                   percent
+                   show0Delta={balance.toNumber() !== 0}
+                   fallbackToPercentPlaceholder
+                   valueChange={countervalueChange}
+                 />
+               </>
              )}
            </Flex>
```

---

<think><details><summary>Thought Process</summary>I have a TypeScript error because I'm trying to use `console.log` as a JSX element, which returns `void`. I need to fix this by either moving the console.log outside of the JSX or using a different approach. Let me fix this.</details></think>

---

```diff
                <>
                  {/* DEBUG: Log Delta props before rendering */}
-                 {console.log(`[AssetRowLayout] About to render Delta for ${currency.id}:`, {
+                 {(() => {
+                   console.log(`[AssetRowLayout] About to render Delta for ${currency.id}:`, {
                      percent: true,
                      show0Delta: balance.toNumber() !== 0,
```

```diff
                      selectedTimeframe,
                      balanceIsZero: balance.toNumber() === 0,
-                 })}
+                   });
+                   return null;
+                 })()}
                  <Delta
                    percent
```

---

<think><details><summary>Thought Process</summary>Good, now let me add comprehensive debug logs to the PortfolioDataContext component to track portfolio aggregation logic.</details></think>

---

```diff
    // Reactive calculations
    const getPortfolioBalance = useCallback((): number => {
-     return portfolioData.cryptoAssets.reduce((total, asset) => {
+     console.log('[PortfolioDataContext] getPortfolioBalance called');
+     
+     const totalBalance = portfolioData.cryptoAssets.reduce((total, asset) => {
        // For static UI, use the balance directly converted to fiat
        // In a real app, this would use live prices
        const estimatedFiatValue = asset.balance * (asset.id === 'bitcoin' ? 97000 : 240);
+       
+       console.log(`[PortfolioDataContext] Asset ${asset.id} balance:`, {
+         balance: asset.balance,
+         estimatedFiatValue,
+         multiplier: asset.id === 'bitcoin' ? 97000 : 240,
+       });
+       
        return total + estimatedFiatValue;
      }, 0);
+     
+     console.log('[PortfolioDataContext] Total portfolio balance:', totalBalance);
+     return totalBalance;
    }, [portfolioData.cryptoAssets]);
  
    const getPortfolioHistory = useCallback((range: string): Array<{ date: Date; value: number }> => {
+     console.log(`[PortfolioDataContext] getPortfolioHistory called for range: ${range}`);
+     
      // Generate modified historical data based on overrides
      const history = calculatePortfolioHistory(portfolioData.cryptoAssets, range);
+     
+     console.log(`[PortfolioDataContext] Generated ${history.length} history points for ${range}`);
      
      // Apply historical multipliers if any
      if (portfolioData.historicalOverrides) {
-       return history.map(point => ({
+       const multiplier = getHistoricalMultiplier(range);
+       console.log(`[PortfolioDataContext] Applying historical multiplier: ${multiplier} for ${range}`);
+       
+       const modifiedHistory = history.map(point => ({
          ...point,
-         value: point.value * getHistoricalMultiplier(range),
+         value: point.value * multiplier,
        }));
+       
+       console.log(`[PortfolioDataContext] Modified history sample:`, {
+         original: history.slice(0, 3),
+         modified: modifiedHistory.slice(0, 3),
+         multiplier,
+       });
+       
+       return modifiedHistory;
      }
      
```

```diff
  
    const getHistoricalMultiplier = (range: string): number => {
+     console.log(`[PortfolioDataContext] getHistoricalMultiplier called for range: ${range}`);
+     
      // Calculate average multiplier across all assets for the given range
      const overrides = portfolioData.historicalOverrides || {};
      const multipliers: number[] = [];
      
-     Object.values(overrides).forEach(assetOverrides => {
+     Object.entries(overrides).forEach(([assetId, assetOverrides]) => {
        if (assetOverrides[range]) {
+         console.log(`[PortfolioDataContext] Found multiplier for ${assetId} ${range}:`, assetOverrides[range]);
          multipliers.push(assetOverrides[range]);
        }
      });
      
-     return multipliers.length > 0 
+     const result = multipliers.length > 0 
        ? multipliers.reduce((sum, m) => sum + m, 0) / multipliers.length 
        : 1;
+       
+     console.log(`[PortfolioDataContext] Historical multiplier result:`, {
+       range,
+       multipliers,
+       averageMultiplier: result,
+     });
+     
+     return result;
    };
  
    const getPortfolioDelta = useCallback((range: string): { value: number; percentage: number } => {
+     console.log(`[PortfolioDataContext] getPortfolioDelta called for range: ${range}`);
+     
      const history = getPortfolioHistory(range);
      
      if (history.length === 0) {
+       console.log(`[PortfolioDataContext] No history data for ${range}, returning zero delta`);
        return { value: 0, percentage: 0 };
      }
+     
+     console.log(`[PortfolioDataContext] Portfolio history analysis for ${range}:`, {
+       totalPoints: history.length,
+       firstPoint: history[0],
+       lastPoint: history[history.length - 1],
+       samplePoints: history.slice(0, 5),
+     });
      
      // Find first significant (non-zero) balance
      const firstSignificantIndex = history.findIndex(b => b.value !== 0);
      const startValue = history[firstSignificantIndex]?.value || 0;
      const endValue = history[history.length - 1]?.value || 0;
+     
+     console.log(`[PortfolioDataContext] Value analysis for ${range}:`, {
+       firstSignificantIndex,
+       startValue,
+       endValue,
+       totalPoints: history.length,
+     });
      
      if (startValue === 0) {
+       console.log(`[PortfolioDataContext] Start value is zero for ${range}, returning zero delta`);
        return { value: 0, percentage: 0 };
      }
      
      const dollarChange = endValue - startValue;
      const percentageChange = dollarChange / startValue;
+     
+     console.log(`[PortfolioDataContext] Delta calculation for ${range}:`, {
+       startValue,
+       endValue,
+       dollarChange,
+       percentageChange,
+       percentageAsPercent: (percentageChange * 100).toFixed(4) + '%',
+       isChangeSmall: Math.abs(percentageChange) < 0.01,
+       isChangeVerySmall: Math.abs(percentageChange) < 0.001,
+     });
      
      console.log(`[getPortfolioDelta] Start: ${startValue}, End: ${endValue}, Change: ${dollarChange} (${(percentageChange * 100).toFixed(2)}%)`);
```

---

<think><details><summary>Thought Process</summary>Now let me also add debug logs to the GraphCard component's Delta component rendering part. I need to fix the console.log issue in the JSX there as well.</details></think>

---

```diff
                        ) : (
                          <>
+                           {/* DEBUG: Log Delta props before rendering */}
+                           {(() => {
+                             console.log('[GraphCard] About to render Delta with props:', {
+                               percent: true,
+                               show0Delta: true,
+                               valueChange: countervalueChange,
+                               context: 'portfolio-percentage',
+                               selectedRange,
+                             });
+                             return null;
+                           })()}
                            <Delta
                              percent
```

```diff
                            />
                            <Text> </Text>
+                           {/* DEBUG: Log Delta props before rendering */}
+                           {(() => {
+                             console.log('[GraphCard] About to render Delta with props:', {
+                               unit: unit,
+                               valueChange: countervalueChange,
+                               context: 'portfolio-value',
+                               selectedRange,
+                             });
+                             return null;
+                           })()}
                            <Delta 
                              unit={unit} 
```

---

<think><details><summary>Thought Process</summary>Perfect! Now I've added comprehensive debug logs to all the key components:

1. **Delta.tsx** - Logs all input props, calculated values, and display logic decisions
2. **GraphCard.tsx** - Logs portfolio calculation analysis, countervalue changes, and Delta props
3. **AssetRowLayout.tsx** - Logs individual asset calculations and comparisons
4. **PortfolioDataContext.tsx** - Logs portfolio aggregation logic and historical data processing

Let me run the app to test these debug logs and see what they reveal about the 0% Delta issue.</details></think>

---

```bash
cd UIReplicationLedger && npm start
```

---

_**User**_

NO more logs, now help me identify a solution to my problem, analyze my logs output,  analyze1w timeframe: Solana shows -2% change but main portfolio Delta still shows 0%   (it should show 2%), and on 1d theres a 1% GAIN FOR SOLANA, BUT it renders a 0% gain and no arrow  

---

_**Assistant**_

<think><details><summary>Thought Process</summary>Looking at the logs, I can see the issue very clearly now. Let me analyze the key problem:

1. **Individual Asset Delta (Working correctly):**
   - 1w Solana: `percentage: -0.018870779203589545` → `delta: -1.8870779203589545` → `roundedDelta: -2` → Shows "-2%"
   - 1d Bitcoin: `percentage: 0.004125205704135756` → `delta: 0.41252057041357554` → `roundedDelta: 0` → Shows "0%"

2. **Portfolio Delta (Problem):**
   - 1w Portfolio: `percentage: -0.0006205068907003382` → `delta: -0.06205068907003382` → `roundedDelta: -0` → Shows "0%"

The issue is in the **Delta component's rounding logic**. Here's what's happening:

```javascript
const delta = percent ? percentage * 100 : value;
const roundedDelta = parseFloat(delta.toFixed(percent ? 0 : 2));
```

When `percent` is true, the code uses `toFixed(0)` which rounds to 0 decimal places. This means:
- `0.41252057041357554` becomes `</details></think>

---

